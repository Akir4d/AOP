#!/usr/bin/env node
const version = 0.18;
const { exec, spawn, spawnSync } = require("child_process");
const fs = require('fs');
const path = require('node:path');
const myArgs = process.argv.slice(2);
const WHICH = (process.platform.startsWith('win')) ? 'set PATH=%PATH%;C:\\xampp\\php\\;D:\\xampp\\php\\ && where' : 'which';
const SPAWNARG = (process.platform.startsWith('win')) ? { stdio: 'inherit', shell: true } : { stdio: 'inherit' };
const params = {};
const readline = require('readline');

R = '\x1b[0;31m';
B = '\x1b[0;34m';
Y = '\x1b[0;33m';
G = '\x1b[0;32m';
N = '\x1b[0m';
E = '\x1b[1m';
NG = '';
PHP = '';
NPM = '';
var ftpPort = 21;
var ftpSecure = false;
var forceClean = false;


class FTPClient {
  constructor(ftp, host = 'localhost', port = 21, username = 'anonymous', password = 'guest', secure = false) {
    this.client = new ftp.Client();
    this.settings = {
      host: host,
      port: port,
      user: username,
      password: password,
      secure: secure
    };
  }

  async setup() {
    if (this.client.closed) {
      this.client.trackProgress(info => {
        info.name=info.name.length?info.name:"Listing";
        let tabs = makeTab(info.name+info.type, 45);
        let trans = (info.type=="upload")?G+E+"Tr"+N:E+"Pr"+N;
        if(info.bytes) {
          let kb = info.bytes/1000;
          let tt=makeTab(String(kb), 10);
          console.log(info.type, "->", B+E+info.name+N, tabs, trans, tt ,info.bytes/1000, "kB");
        }
      })
      await this.client.access(this.settings);
    }
  }

  async removeByExtension(ext) {
    let files = await this.client.list();
    for (let file of files) {
      if (file.type == 1 && file.name.includes('.' + ext)) {
        await this.client.remove(file.name);
      }
    }
  }

  async exists(exist) {
    let files = await this.client.list();
    for (let file of files) {
      if (file.name == exists) {
        return true;
      }
    }
  }


  async removeAngularFiles() {
    await this.removeByExtension('css');
    await this.removeByExtension('js');
    await this.removeByExtension('html');
  }

  upload(sourcePath, remotePath) {
    (async () => {
      try {
        await this.setup();
        if (forceClean) {
          await this.client.ensureDir(remotePath);
          await this.client.clearWorkingDir();
        } else {
          await this.removeAngularFiles();
        }
        await this.client.uploadFromDir(sourcePath, remotePath);
        if (fs.existsSync(path.join(sourcePath, 'backend'))) {
          await this.client.cd('backend');
        }
        await this.client.cd('aop_modules');
        await this.client.cd('versions');
        await this.removeByExtension('txt');
      } catch (err) {
        console.log(err);
      }
      this.close();
    })();
  }

  close() {
    this.client.close();
    process.exit(0);
  }

}

const parseArguments = () => {
  for (let a = 0; myArgs.length > a; a++) {
    let m = myArgs[a];
    if (typeof m == 'string' && m.startsWith('-')) {
      let search = m.split('=')[0];
      switch (search) {
        case '-u':
          params.username = myArgs[++a];
          break;
        case '--username':
          params.username = m.split('=')[1];
          break;
        case '-p':
          params.password = myArgs[++a];
          break;
        case '--password':
          params.password = m.split('=')[1];
          break;
        case '-c':
          params.copy = myArgs[++a];
          break;
        case '--copy':
          params.copy = m.split('=')[1];
          break;
        case '-fp':
          ftpPort = myArgs[++a];
          break;
        case '--ftp-port':
          ftpPort = m.split('=')[1];
          break;
        case '--force-clean':
          forceClean = true;
          break;
      }
    } else {
      if (!params.hasOwnProperty('command')) params.command = m;
    }
  }
}

const makeTab = (name, len) => {
  let t = (name>0)?parseInt(name):1;
  t=len-name.length;
  t=t>0?t:1;
  let tabs = "";
  for(let a=0;t>a;a++)tabs+=" "
  return tabs;
}

const copyFileSync = (source, target) => {

  var targetFile = target;

  // If target is a directory, a new file with the same name will be created
  if (fs.existsSync(target)) {
    if (fs.lstatSync(target).isDirectory()) {
      targetFile = path.join(target, path.basename(source));
    }
  }
  fs.writeFileSync(targetFile, fs.readFileSync(source));
}

const ftpSync = (source, target) => {
  if (forceClean) {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    rl.question(`${R}${E}--force-clean\n\n is a personal developer feature that will erase all files from the ftp remote folder before copying on it.\n\n - Are you sure you want to use it?\n\n - Have you backed up this folder? ${N} [${G}${E}NO${N}]/${R}${E}yes${N} `, ans => {
      if (ans == 'yes') {
        ftpSyncReal(source, target);
      } else {
        process.exit(0);
      }
    });
  } else {
    ftpSyncReal(source, target);
  }

}


const ftpSyncReal = (source, target) => {
  var ftp = null;
  try {
    ftp = require(path.join(process.cwd(), 'node_modules', 'basic-ftp'));
  } catch (e) {
    spawnSync(NPM, ['install', 'basic-ftp', '--save'], SPAWNARG);
    ftp = require(path.join(process.cwd(), 'node_modules', 'basic-ftp'));
  }

  if (ftp != null) {
    let cred, chost, user, pass = '';
    if (params.hasOwnProperty('username')) {
      user = params.username;
      pass = params.password;
      let ll = target.split('@');
      chost = (typeof ll[1] == "undefined")?ll[0]:ll[1];
    } else {
      [cred, chost] = target.split('@');
      [user, pass] = cred.split(':');
    }
    let [host, tar] = chost.split(':');
    tar = (tar == null) ? '' : tar;
    const ftpClient = new FTPClient(ftp, host, ftpPort, user, pass, ftpSecure);
    ftpClient.upload(source, tar);
  }
}

const copyFolderRecursiveSync = (source, target) => {
  var files = [];

  // Check if folder needs to be created or integrated
  var targetFolder = path.join(target, path.basename(source));
  if (!fs.existsSync(targetFolder)) {
    fs.mkdirSync(targetFolder);
  }

  // Copy
  if (fs.lstatSync(source).isDirectory()) {
    files = fs.readdirSync(source);
    files.forEach(function (file) {
      var curSource = path.join(source, file);
      if (fs.lstatSync(curSource).isDirectory()) {
        copyFolderRecursiveSync(curSource, targetFolder);
      } else {
        copyFileSync(curSource, targetFolder);
      }
    });
  }
}

const copyInsideSourceRecursiveSync = (source, target, show=false) => {
  if (!fs.existsSync(target)) {
    fs.mkdirSync(target);
  }
  let files = fs.readdirSync(source);
  
  for (let file of files) {
    let np = path.join(source, file);
    
    if(show)console.log('copying', B+E+np+N, makeTab(np,50),'->', G+E+target+N)
    if (fs.lstatSync(np).isDirectory()) {
      copyFolderRecursiveSync(np, target);
    } else {
      copyFileSync(np, target);
    }
  }
}

const usage = u => {
  console.log(`\n${R}${E}usage${N}: node aop [Command] [ARG]\n\nCommands:
    ${G}${E}serve${N}\t- starts ${E}Angular${N} and ${E}Codeigniter${N} develop serve at ${Y}${E}http://localhost:4200${N} and ${Y}${E}http://localhost:8085${N}
    ${G}${E}spark${N}\t- starts ${E}Codeigniter${N} spark utility
    ${G}${E}ng${N}   \t- calls  ${E}Angular${N} ng utility
    ${G}${E}build${N}\t- builds a complete plug and play package on ${Y}${E}build/${N} folder
    ${G}${E}build:others${N}- for all servers that do not support ".htaccess" this produces a complete plug-and-play package \n\t \t  on the build folder, for security reasons, "public" is the only sub-folder you have to share.
    ${G}${E}copy${N}\t- copy your build to a folder or remote ftp server with syntax ${Y}${E}ftp://user:pass@host[:path]${N}
    ${G}${E}install${N}\t- installs aop on system
    \n\nOptions:
    ${G}${E}-c${N} path or ${G}${E}--copy=path${N}\t after build command will copy the build to a folder or remote ftp server with syntax ${Y}${E}ftp://user:pass@host[:path]${N}
    ${G}${E}-p${N} port or ${G}${E}--port=port${N}\t change the default ftp port.\n\nversion: ${version}
  `);
  process.exit(0)
}

const check = f => {
  exec(WHICH + ' npm', (error, stdout) => {
    if (error) {
      console.log(`${R}${E}error:${N}${E} unable to find npm executable${N}`);
      return;
    } else {
      NPM = stdout.split("\n")[0].trim().replaceAll(' ', '" "');
      if (!fs.existsSync('node_modules')) {
        spawnSync(NPM, ['install'], SPAWNARG);
      }
      exec(WHICH + ' php', (error, stdout) => {
        if (error) {
          console.log(`${R}${E}error:${N}${E} unable to find php executable${N}`);
          return;
        } else {
          PHP = stdout.split("\n")[0].trim().replaceAll(' ', '" "');;
          exec(WHICH + ' ng', (error, stdout) => {
            if (error) {
              console.log(`${G}${E}Installing missed ng command:${N}`);
              npmprecess = spawn(NPM, ['install', '-g', '@angular/cli'], SPAWNARG);
              npmprecess.on('exit', () => check(f));
              return;
            } else {
              NG = stdout.split("\n")[0].trim().replaceAll(' ', '" "');;
              f();
            }
          });
        }
      });
    }
  });
}

const serve = () => {
  if (!fs.existsSync('.env')) copyFileSync('env_develop', '.env');
  const codeigniter = spawn(PHP, ['spark', 'serve', '--port', 8085], SPAWNARG);
  const angular = spawn(NG, ['serve'], SPAWNARG);
  process.on('SIGINT', () => {
    console.log(`\n\n${R}${E}Killed${N}${N}:\n ${G}✔${N} ${E}ng serve${N} with pid: ${G}${angular.pid}${N} \n ${G}✔${N} ${E}spark serve${N} with pid: ${G}${codeigniter.pid}${N}`);
    angular.kill;
    codeigniter.kill;
  });
}

const buildForApache = e => {
  fs.rmSync('build', { recursive: true, force: true });
  copyInsideSourceRecursiveSync('public', 'build');
  fs.mkdirSync(path.join('build', 'backend'));
  copyFolderRecursiveSync('aop_modules', path.join('build', 'backend'));
  copyFolderRecursiveSync('app', path.join('build', 'backend'));
  copyFolderRecursiveSync('writable', path.join('build', 'backend'));
  copyFileSync('env_production', path.join('build', 'backend', '.env'));
  copyFileSync('composer.json', path.join('build', 'backend'));
  copyFileSync(path.join('app', '.htaccess'), path.join('build', 'backend'));
  fs.writeFileSync(path.join('build', 'index.php'), fs.readFileSync(path.join('build', 'index.php'), 'utf-8').replaceAll('../', 'backend/'));
  fs.mkdirSync(path.join('build', 'backend', 'cache'));
  copyBuild();
}

const buildForOthers = e => {
  fs.rmSync('build', { recursive: true, force: true });
  fs.mkdirSync('build');
  copyFolderRecursiveSync('public', 'build');
  copyFolderRecursiveSync('aop_modules', path.join('build'));
  copyFolderRecursiveSync('app', path.join('build'));
  copyFolderRecursiveSync('writable', path.join('build'));
  copyFileSync('env_production', path.join('build', '.env'));
  copyFileSync('composer.json', path.join('build'));
  copyFileSync('.htaccess', path.join('build'));
  fs.mkdirSync(path.join('build', 'cache'));
  copyBuild();
}

const copyBuild = () => {
  if (params.hasOwnProperty('copy')) {
    for (let rem of ['public', 'index.php', 'main.html', '.env', '.htaccess'])
      if (fs.existsSync(path.join(params.copy, rem)))
        fs.rmSync(path.join(params.copy, rem), { recursive: true, force: true });
    switch (params.copy.slice(0, 6)) {
      case 'ftp://':
        ftpSync('build', params.copy.slice(6));
        break;
      case 'sftp:/':
      case 'ftps:/':
        ftpSecure = true;
        ftpSync('build', params.copy.slice(7));
        break;
      default:
        copyInsideSourceRecursiveSync('build', params.copy, true);
        let fistup = ['aop_modules', 'versions', 'firstup.info.txt'];
        if (fs.existsSync(path.join(params.copy, 'backend', ...fistup))) {
          fs.rmSync(path.join(params.copy, 'backend', ...fistup));
        } 
        if (fs.existsSync(path.join(params.copy, ...fistup))) {
          fs.rmSync(path.join(params.copy, ...fistup));
        }  
    }
  }
}


const installAOP = e => {
  if (!fs.existsSync('.env')) copyFileSync('env_develop', '.env');
  let nodePath = path.normalize(path.join(NG, '..'));
  copyFileSync('aop', nodePath, { overwrite: true | false });
  if (process.platform.startsWith('win')) {
    fs.writeFileSync(path.join(nodePath, 'aop.cmd'), `@ECHO off
    GOTO start
    :find_dp0
    SET dp0=%~dp0
    EXIT /b
    :start
    SETLOCAL
    CALL :find_dp0
    
    IF EXIST "%dp0%\\node.exe" (
      SET "_prog=%dp0%\\node.exe"
    ) ELSE (
      SET "_prog=node"
      SET PATHEXT=%PATHEXT:;.JS;=;%
    )
    
    endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & "%_prog%"  "%dp0%\\aop" %*`);
    copyFileSync('aop.cmd', nodePath);
  } else {
    fs.chmodSync(path.join(nodePath, 'aop'), '755');
  }
}


const menu = () => {
  parseArguments(myArgs);
  switch (params.command) {
    case 'serve':
      serve();
      break;
    case 'spark':
      spawn(PHP, myArgs, SPAWNARG);
      break;
    case 'ng':
      spawn(NG, myArgs, SPAWNARG);
      break;
    case 'build':
      spawnSync(NG, ['build'], SPAWNARG);
      buildForApache();
      break;
    case 'build:others':
      spawnSync(NG, ['build'], SPAWNARG);
      buildForOthers();
      break;
    case 'install':
      installAOP();
      break;
    case 'copy':
      params.copy = myArgs[1];
      copyBuild();
      break;
    default:
      usage();
  }
}

let filePath = path.join(process.cwd(), 'aop');
if (fs.existsSync(filePath)) {
  const fileContent = fs.readFileSync(filePath, { encoding: 'utf-8' });
  let pathVersion = parseFloat(fileContent.split('\n')[1].split('=')[1].split(';')[0].trim());
  if (pathVersion > version) {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    rl.question(`${Y}${E}Detected new aop version (${pathVersion}) in this folder, would you like to update ${N}? [${G}${E}yes${N}]/${R}${E}no${N} `, ans => {
      if (ans !== 'no') {
        check(() => {
          installAOP();
          console.log(`${R}${E}Reload this script${N}`);
          process.exit(0);
        });
      } else {
        myStart();
      }

    });
  } else {
    myStart();
  }
}

function myStart() {
  if (myArgs.length == 0) {
    usage();
  } else {
    check(menu);
  }
}


